;function makeitglob_new, sensor, noaanumber, year, month, day
@../../Library/library/jrc_core/mapQualityFlags
;@../../Library/library/jrc_core/mapQualityFlags
function doFapar, sensor, resolution, missionName, mainVarName, missionCode, year, month, day, $
  sourceDir, outputDir, tempdir, $
  OVERWRITE=OVERWRITE, FIRST_LOOK=FIRST_LOOK, TYPE1=TYPE1, TYPE2=TYPE2


  if ~obj_valid(operatorObj) then operatorObj=obj_new('GenericOperator')
  if ~obj_valid(fsObj) then fsObj=obj_new('FileSystem', /STAND)
  ;NaN=-9999 ;!VALUES.F_NAN

  outputDir=fsObj->adjustDirSep(outputDir, /ADD)
  sourceDir=fsObj->adjustDirSep(sourceDir, /ADD)
  tempDir=fsObj->adjustDirSep(tempDir, /ADD)

  yearS=string(year, format='(I04)')
  monthS=string(month, format='(I02)')
  dayS=string(day, format='(I02)')

  sourceFileName=buildBrfFileName_D(sensor, resolution, year, month, day, missionName, missionCode, mainVarName)
  if sensor eq 'AVH09C1' then new_file=buildAVHRRFAPARFileName_D(sensor, resolution, year, month, day, missionName, missionCode, mainVarName)
  if sensor eq 'MODIS' then new_file=buildMODISFAPARFileName_D(sensor, resolution, year, month, day, missionName, missionCode, mainVarName)

  ;resFName='AVHRR_'+'GEOG_0.05DEG'+'_'+years+'_'+months+'_'+days+'_NOAA-N'+strcompress(noaaCode, /REMOVE)+'_BRF'
  ;sourceFileNC=fsObj->addFileExtension(sourceDir+sourceFileName, 'nc')
  sourceFileNC=fsObj->addFileExtension(sourceFileName, 'nc')
  ncfilename=fsObj->addFileExtension(outputDir+new_file, 'NC')
  hdffilename=fsObj->addFileExtension(outputDir+new_file, 'HDF')
  ;resFileHDF=fsObj->addFileExtension(filePath+resFName, 'hdf')

  checkInput=file_info(sourceDir+sourceFileNC)
  checkOutput1=file_info(ncfilename)
  checkOutput2=file_info(hdffilename)

  if checkInput[0].size eq 0 then NOHDFAVAILABLE=1
  if checkOutput1[0].size ne 0 and ~keyword_set(OVERWRITE) then NOWRITENC=1
  if checkOutput2[0].size ne 0 and ~keyword_set(OVERWRITE) then NOWRITEHDF=1
  ;if checkHDF[0].size ne 0 and ~keyword_set(OVERWRITE) then NONCWRITE=1

  if keyword_set(NOHDFAVAILABLE) or (keyword_set(NOHDFWRITE) and keyword_set(NOHDFWRITE)) then return, -1

  data=readBRF(sourceDir, sourceFileNC, FOUND=FOUND)

  if ~keyword_set(FOUND) then return, -1

  INT_NAN=-9999
  DATA_RANGE=[0., 1.]
  DATA_NAN=255


  ;ncfilename=sourceDir+new_file+'.NC'
  ;print, dirout+new_file

  output={  ExpId_t, $
    fpar: fltarr(7200,3600), $
    sigma: fltarr(7200,3600), $
    red: fltarr(7200,3600), $
    sigma_red:fltarr(7200,3600), $
    nir: fltarr(7200,3600), $
    sigma_nir: fltarr(7200,3600), $
    flag: bytarr(7200,3600), $
    toc_red: fltarr(7200,3600), $
    toc_nir: fltarr(7200,3600), $
    qa: bytarr(7200,3600),$
    sza: bytarr(7200,3600)}
  ;
  ; initialization
  ;
  output.fpar(*,*)=255
  output.sigma(*,*)=255
  output.red(*,*)=255
  output.sigma_red(*,*)=255
  output.nir(*,*)=255
  output.sigma_nir(*,*)=255
  noaanumber=missionCode
  ;
  ;
  ;
  ;if noaanumber eq '16' then dirroot='/net/netsea2/vol/vol06/data/projects/QA4ECV/WP4/AVHRR/AVHRR/'
  ;if noaanumber eq '14' then dirroot='/net/netseA2/vol/vol24_h07/archive-from-oldstorage/froz/vol07/gobrona/LDTR/AVHRR/BRDF/'
  ;dirout='/net/netsea2/vol/vol06/data/projects/QA4ECV/WP4/AVHRR/FAPAR/'

  ;if noaanumber eq '16' then dirroot='E:\mariomi\Documents\projects\LDTR\data\input\AVHRR\2003\'
  ;if noaanumber eq '14' then dirroot='E:\mariomi\Documents\projects\LDTR\data\input\BRDF\1999\'
  ;dirout='E:\mariomi\Documents\projects\LDTR\data\output\FAPAR_COEFF'


  ;
  ;====================================================================
  ;
  ; should be only once for all outside the program
  ;
  ; retrieve the scale_factor and offset
  ;
  ;  if noaanumber eq '16' then begin
  ;    file_sds='GLOBAL_L3_GEOG_0.05DEG_001-001_03.NOAA-16.hdf'
  ;    read_data, dirroot, file_sds,'RHO1', red_avhrr, slope_red, offset_red
  ;    read_data, dirroot, file_sds,'RHO2', nir_avhrr, slope_nir, offset_nir
  ;    ;
  ;    read_data, dirroot, file_sds,'TS', ts_avhrr, slope_ts, offset_ts
  ;    read_data, dirroot, file_sds,'TV', tv_avhrr, slope_tv, offset_tv
  ;    read_data, dirroot, file_sds,'PHI', phi_avhrr, slope_phi, offset_phi
  ;  endif
  ;
  ;
  ;=================================================================================
  ;readFileName=buildBrfFileName_D(sensor, resolution, year, month, day, missionName, missionCode, mainVarName, 'nc')
  ;fName='AVHRR_'+'GEOG_0.05DEG'+'_'+years+'_'+months+'_'+days+'_NOAA-N'+strcompress(noaaCode, /REMOVE)+'_BRF'


  ;

  red_avhrr=data.red_avhrr & slope_red=data.slope_red & offset_red=data.offset_red
  nir_avhrr=data.nir_avhrr & slope_nir=data.slope_nir & offset_nir=data.offset_nir
  ts_avhrr=data.ts_avhrr & slope_ts=data.slope_ts & offset_ts=data.offset_ts
  tv_avhrr=data.tv_avhrr & slope_tv=data.slope_tv & offset_tv=data.offset_tv
  phi_avhrr=data.phi_avhrr & slope_phi=data.slope_phi & offset_phi=data.offset_phi
  qa_avhrr=data.brdf_qa_avhrr & slope_brdf_qa=data.slope_qa & offset_brdf_qa=data.offset_qa
  ;save memory
  data=0
  avhrrdays=julday(month,day,year)-julday(01,01,year)+1
  ;print, avhrrdays
  ;

  ;if strlen(file_eric) ge 1 then begin

  sizemat=size(red_avhrr)
  ;
  ; START
  ;
  ;
  reflectance=DBLARR(sizemat(1),sizemat(2),2)
  ;
  reflectance(*,*,0)=red_avhrr(*,*)*slope_red(0)+offset_red(0)
  reflectance(*,*,1)=nir_avhrr(*,*)*slope_nir(0)+offset_nir(0)
  ;
  angles=DBLARR(sizemat(1),sizemat(2),4)
  ;
  ;
  ; verify WITH eRIC AND mARTIN IF CORRECT
  ;
  angles(*,*,0)=ts_avhrr(*,*)*slope_ts(0)+offset_ts(0)
  angles(*,*,1)=tv_avhrr(*,*)*slope_tv(0)+offset_tv(0)
  ;
  output.sza=ts_avhrr(*,*)
  ; correction already applied
  ;RELAZ=phi_avhrr(*,*)*slope_phi(0)+offset_phi(0)
  ;SIN_REL_AZ = sin(RELAZ*!pi/180.)
  ;COS_REL_AZ = cos(RELAZ*!pi/180.)
  ;GOOD_REL_AZ = atan(SIN_REL_AZ, COS_REL_AZ)
  ;angles(*,*,2)=good_rel_az*180./!pi
  angles(*,*,2)=phi_avhrr
  ;
  ;
  ;
  angles(*,*,3)=0.0
  ;
  ;
  flagstoc= bytarr(7200, 3600)

  red = [0,0,1,0,0.66,0.68,0.,0.55,0.00,0.00,0.85,0,00,0.]
  gre = [1,0,0,0,0.00,0.00,0.,0.55,0.77,0.66,0.00,0.00,0.]
  blu = [0,0,0,1,0.00,1.00,1.,1.00,1.00,0.55,0.80,0.77,0.]
  TVLCT, red*255, gre*255, blu*255

  flag2 = CheckDataTOC(red_avhrr*slope_red(0)+offset_red(0), nir_avhrr*slope_nir(0)+offset_nir(0))
  flagstoc=flag2
  ;
  ;stop
  ;
  ;flag_angles = CheckAngle(angles(*,*,0), angles(*,*,1))
  ;window, 10, xsize=720, ysize=360, title='FPAR Angles'+SENSOR
  ;tv, reverse(congrid(flag_angles, 720,360),2)
  ;

  red_avhrr=0.
  nir_avhrr=0.
  ts_avhrr=0.
  tv_avhrr=0.
  phi_avhrr=0.
  ;
  ;=======================================================================
  ;
  ;	AOT
  ;
  ;=========================================================================
  ;read_data, dirroot, file_eric,'AOT', AOT, slope_aot, offset_aot

  ;window, 12, xsize=720, ysize=360, title='AAOT '+SENSOR
  ;tv, reverse(congrid(bytscl(aot*slope_aot(0)+offset_aot(0), min=0., max =0.8), 720,360),2)

  ;stop
  ;
  ;	0      Band 1 BRDF corrected;
  ;	       1 -- yes
  ;	       0 -- no
  ;	5      Band 2 BRDF corrected;
  ;	       1 -- yes
  ;	       0 -- no
  ;
  ;
  ;=======================================================================================

  rrq1=cgi_map_bitwise_flag(qa_avhrr,0)
  rrq2=cgi_map_bitwise_flag(qa_avhrr,5)
  ;
  idx_nocorr=where (rrq1 eq 0 or rrq2 eq 0)
  ;window,0, xsize=720*2, ysize=360*2
  ;tvscl, reverse(congrid(rrq1, 720*2, 360*2), 2)
  ;stop

  ;=====================================================================================
  ;
  ;
  ;1      Pixel is cloudy;
  ;   		1 -- yes
  ;	       0 -- no

  ;rr1=cgi_map_bitwise_flag(qc_avhrr,1)
  rr1=cgi_map_bitwise_flag(qa_avhrr,1)
  ;
  ;
  ; 2      Pixel contains cloud shadow;
  ;	       1 -- yes
  ;	       0 -- no
  ;
  ;rr2=cgi_map_bitwise_flag(qc_avhrr,2)
  rr2=cgi_map_bitwise_flag(qa_avhrr,2)
  ;
  ;  9 channel 2 value is invalid 1 = yes, 0 = no
  ;  8 Channel 1 value is invalid 1 = yes, 0 = no
  ;
  ;rr21=cgi_map_bitwise_flag(qc_avhrr,9)
  ;rr22=cgi_map_bitwise_flag(qc_avhrr,8)
  rr21=cgi_map_bitwise_flag(qa_avhrr,9)
  rr22=cgi_map_bitwise_flag(qa_avhrr,8)
  ;
  ;
  idxbad=where(rr21 eq 1 or rr22 eq 1)
  ;
  ; 3      Pixel is over water;
  ;	       1 -- yes
  ;	       0 -- no
  ;rr3=cgi_map_bitwise_flag(qc_avhrr,3)
  rr3=cgi_map_bitwise_flag(qa_avhrr,3)
  ;
  ;
  ;
  ;
  idx_mask = where(rr1 eq 1) ; or rr2 eq 1)		;----> cloud
  idx_mask2 = where(rr21 eq 1 or rr22 eq 1)		;----> invalid
  IDX_SEA=  where(rr3 eq 1)




  flag2(idxbad)=7.0		;	< bad


  S=SIZE(FLAG2)
  MASK_AVHRR=BYTARR(S(1),S(2))
  ;
  MASK_AVHRR(IDX_MASK)=2		;----> cloud
  ;MASK_AVHRR(IDX_MASK2)=2
  ;MASK_AVHRR(idx_nocorr)= 130
  ;flag2(idx_mask)=2.0

  MASK_AVHRR(IDX_SEA)= 3
  flag2(idx_sea)=3.0
  ;window, 11, xsize=720, ysize=360, title='QA '+SENSOR
  ;tv, reverse(congrid(MASK_avhrr, 720,360),2)

  ;MASK_AVHRR(idx_nocorr)= 0
  ;window, 11, xsize=720*2, ysize=360*2, title='QA '+SENSOR
  ;tv, reverse(congrid(MASK_avhrr, 720*2,360*2),2)
  ;stop
  ;
  ;window, 12, xsize=720*2, ysize=360*2, title='FLAG '+SENSOR
  ;tv, reverse(congrid(flag2, 720*2,360*2),2)
  ;
  ;stop
  ;
  ;

  if sensor eq 'AVH09C1' then begin
    ;if sensor eq 'AVHRR' then begin
    sza=angles[*,*,0] ;/180.*!pi
    vza=angles[*,*,1] ;/180.*!pi
    saa=angles[*,*,2] ;/180.*!pi
    vaa=angles[*,*,3] ;/180.*!pi
    ;
    ;
    red=reflectance(*,*,0)
    nir=reflectance(*,*,1)

    ;
    ; use nasa formulae for toc band ... 0.05Ï+0.005
    ;
    D_BRF_ToA_RED=2.*(red*0.05+0.005)
    D_BRF_ToA_NIR=2.*(nir*0.05+0.005)
    ;
    ;
    ;
    ; make the process only over vegetated areas
    ;
    idx=where(flag2 eq 0)
    ;NOAString=strcompress(noaanumber, /REMOVE)
    NOAString=string(noaanumber, format='(I02)')
    if idx(0) ge 0 then begin

      FAPAR,'AVHRR', NOAString,sza(idx),vza(idx),saa(idx),vaa(idx),$
        red(idx),red(idx),nir(idx),$
        D_BRF_ToA_RED(idx),D_BRF_ToA_RED(idx),D_BRF_ToA_NIR(idx), $
        rhoRED, rhoNIR, D_rhoRED, D_rhoNIR, $
        D_rhotildeBLUE, D_rhotildeRED, D_rhotildeNIR, VI, D_VI, /TOC
      ;
      output.fpar(idx)=vi
      output.sigma(idx)=d_vi
      output.red(idx)=rhoRED
      output.nir(idx)=rhoNIR
      output.sigma_red(idx)=D_rhoRED
      output.sigma_nir(idx)=D_rhoNIR
      ;
      ;
      ;
      ;window,3
      ;plot, [0.,1.],[0.,1.], psym=1, yr=[0.,1.], xr=[0.,1.]
      ;for k=0, N_elements(idx)-1, 50 do plots, red(idx(k)), nir(idx(k)), psym=4, col=output.fpar(idx(k))*250.0
      ;stop

      idx_neg=where(output.fpar le 0.0)
      output.fpar(idx_neg)=0.0
      idx_big=where(output.fpar ge 1.0 and output.fpar le 10.0)
      output.fpar(idx_big)=1.0
      flag2(idx_neg)=4.0
      flag2(idx_big)=6.0
      FAPARCOLOR
      ;window, 0, xsize=720*2, ysize=360*2, title='FPAR '+SENSOR
      ;tv, reverse(congrid(output.fpar*250, 720*2,360*2),2)
      ;
      ;window, 1, xsize=720*2, ysize=360*2, title='New FLAG '+SENSOR
      ;tvscl, reverse(congrid(flag2, 720*2,360*2),2)
      ;stop
      ;
      ;	window, 1, xsize=720, ysize=360, title='Dev FPAR '+SENSOR
      ;    	tv, reverse(congrid(output.sigma*2.*250., 720,360),2)
      ;
      ;	window, 2, xsize=720, ysize=360, title='Rectified Red '+SENSOR
      ;    	tv, reverse(congrid(bytscl(output.sigma_red, min=0., max=0.1), 720,360),2)
      ;


      ;img=fltarr(7200,3600)
      ;img(idx)=rhoRED
      ;
      ;	window, 2, xsize=720, ysize=360, title='Rectified Red '+SENSOR
      ;    	tvscl, reverse(congrid(img, 720,360),2)
      ;
      ;
    endif
  endif
  ;
  ;
  ;stop
  ; make the process of rectifed only over bare soil
  ;
  idx_soil=where(flag2 eq 4)

  if idx_soil(0) ge 0 then begin
    ;
    ;
    ; BUG HERE AS DEPEND ON ANGLES ...
    ;
    sza=angles[*,*,0] ;/180.*!pi
    vza=angles[*,*,1] ;/180.*!pi
    saa=angles[*,*,2] ;/180.*!pi
    vaa=angles[*,*,3] ;/180.*!pi


    Rectified,'AVHRR', NOAString,sza(idx_soil),vza(idx_soil),saa(idx_soil),vaa(idx_soil),$
      red(idx_soil),red(idx_soil),nir(idx_soil),$
      D_BRF_ToA_RED(idx_soil),D_BRF_ToA_RED(idx_soil),D_BRF_ToA_NIR(idx_soil), $
      rhoRED_S, rhoNIR_S, D_rhoRED_S, D_rhoNIR_S, $
      D_rhotildeBLUE_S, D_rhotildeRED_S, D_rhotildeNIR_S, vi_s, d_vis, /TOC
    ;;
    output.fpar(idx_soil)=0.0
    output.sigma(idx_soil)=0.0
    output.red(idx_soil)=rhoRED_S
    output.nir(idx_soil)=rhoNIR_S
    output.sigma_red(idx_soil)=D_rhoRED_S
    output.sigma_nir(idx_soil)=D_rhoNIR_S
    ;
    ;img=fltarr(7200,3600)
    ;img(idx_soil)=rhoRED_S
    ;

    ;
    ;stop
  endif
  ;
  ;PPMSA_ALBEDOCOLOR
  ;	window, 4, xsize=720, ysize=360, title='Rectified Red '+SENSOR
  ;    	tv, reverse(congrid(bytscl(output.red, min=0., max=0.6), 720,360),2)
  output.flag=flag2
  ;
  idx_1 = where (flag2 eq 1)
  idx_2 = where (flag2 eq 2)
  idx_3 = where (flag2 eq 3)
  ;
  ;idx_4 = where (flag_angles eq 1)
  ;idx_5 = where (flag_angles eq 2)
  ;
  ;
  ;, ZEROISNAN=ZEROISNAN, VALUE_BYTES=VALUE_BYTES, DATA_MIN=DATA_MIN, DATA_MAX=DATA_MAX, DATA_NAN_RANGE=DATA_NAN_RANGE
  ZEROISNAN=keyword_set(TYPE1) ;0
  ;byteOutput=dataByteScaling(output.fpar, NAN_BYTE_VALUE=0, VALUE_BYTES=[1,255])
  ;byteOutput=dataByteScaling(output.fpar, NAN_BYTE_VALUE=0, VALUE_BYTES=[1,255])
  ;byteOutput=dataByteScaling(output.fpar, VALUE_BYTES=[0,250])
  remarkableFlags=[255,254,253]
  if keyword_set(ZEROISNAN) then begin
    DATA_NAN=255
    BYTE_NAN=0
    BYTE_RANGE=[1,255]
    remarkableFlags[*]=BYTE_NAN
  endif else begin
    DATA_NAN=255
    BYTE_NAN=255
    BYTE_RANGE=[0,250]
  endelse

  res=dataByteScaling(output.fpar, output.flag, FLAG_VALUES=[9,10], $
    DATA_NAN=DATA_NAN, BYTE_NAN=BYTE_NAN, $
    DATA_RANGE=DATA_RANGE, BYTE_RANGE=BYTE_RANGE)
  output.fpar=res.resultData
  output.flag=res.resultFlag

  res=dataByteScaling(output.sigma, output.flag, $
    DATA_NAN=DATA_NAN, BYTE_NAN=BYTE_NAN, $
    DATA_RANGE=DATA_RANGE, BYTE_RANGE=BYTE_RANGE)
  output.sigma=res.resultData
  output.flag=res.resultFlag

  res=dataByteScaling(output.red, output.flag, FLAG_VALUES=[9,10], $
    DATA_NAN=DATA_NAN, BYTE_NAN=BYTE_NAN, $
    DATA_RANGE=DATA_RANGE, BYTE_RANGE=BYTE_RANGE)
  ;output.red=res.resultData
  output.flag=res.resultFlag

  res=dataByteScaling(OUTPUT.SIGMA_RED, output.flag, $
    DATA_NAN=DATA_NAN, BYTE_NAN=BYTE_NAN, $
    DATA_RANGE=DATA_RANGE, BYTE_RANGE=BYTE_RANGE)
  ;output.sigma_red=res.resultData
  output.flag=res.resultFlag

  res=dataByteScaling(output.nir, output.flag, FLAG_VALUES=[13,14], $
    DATA_NAN=DATA_NAN, BYTE_NAN=BYTE_NAN, $
    DATA_RANGE=DATA_RANGE, BYTE_RANGE=BYTE_RANGE)
  ;output.nir=res.resultData
  output.flag=res.resultFlag

  res=dataByteScaling(output.sigma_nir, output.flag, $
    DATA_NAN=DATA_NAN, BYTE_NAN=BYTE_NAN, $
    DATA_RANGE=DATA_RANGE, BYTE_RANGE=BYTE_RANGE)
  ;output.sigma_nir=res.resultData
  output.flag=res.resultFlag

  flagTags=strupcase(['fpar', 'sigma'])
  tags=tag_names(output)

  for i=0, n_elements(flagTags)-1 do begin
    thisIdx=(where(flagTags[i] eq tags, count))[0]
    if count eq 1 then begin
      output.(thisIdx)=mapQualityFlags(output.(thisIdx), idx_1, remarkableFlags[0])
      output.(thisIdx)=mapQualityFlags(output.(thisIdx), idx_2, remarkableFlags[1])
      output.(thisIdx)=mapQualityFlags(output.(thisIdx), idx_3, remarkableFlags[2])
    endif
  endfor

  ;map -9999 on int data
  flagTags=strupcase(['red', 'nir', 'sigma_red', 'sigma_nir'])
  for i=0, n_elements(flagTags)-1 do begin
    thisIdx=(where(flagTags[i] eq tags, count))[0]
    nanIdxs=where(output.(thisIdx) gt 250, count)
    output.(thisIdx)=mapQualityFlags(output.(thisIdx), nanIdxs, INT_NAN)
  endfor

  ;
  ;if idx_4(0) ge 0 then img(idx_4)=-9996.0
  ;
  ;if idx_5(0) ge 0 then img(idx_5)=-9995.0
  ;
  ;
  ;

  print,'Write the results in ',outputDir+new_file
  ;
  ;
  ;
  ;
  ;idx_4 = where (flag_angles eq 1)
  ;idx_5 = where (flag_angles eq 2)
  ;
  ;
  ;if idx_3(0) ge 0 then img(idx_3)=0.0
  ;
  ;if idx_2(0) ge 0 then img(idx_2)=-9998.0
  ;
  ;if idx_1(0) ge 0 then img(idx_1)=-9997.0
  ;
  ;if idx_4(0) ge 0 then img(idx_4)=-9996.0
  ;
  ;if idx_5(0) ge 0 then img(idx_5)=-9995.0
  ;
  ;
  ; create output file
  ;
  ;
  bandNames=['FAPAR','Sigma FAPAR', $
    'RECTIFIED RED', 'Sigma RECTIFIED RED', $
    'RECTIFIED NIR', 'Sigma RECTIFIED NIR', $
    'FLAG', $
    'TS', 'TV', 'PHI', $
    'BRF TOC RED', 'BRF TOC NIR', $
    'MASK']

  bandMeasaureUnits=['FAPAR mu','-', $
    '-', 'RECTIFIED RED mu', $
    '-', 'RECTIFIED NIR mu', $
    '-', $
    'deg','deg','deg', $
    'BRF TOC RED mu', 'BRF TOC NIR mu', $
    '-']
  dims=size(output.fpar, /DIMENSIONS)
  if keyword_set(FIRST_LOOK) then begin
    fLookDir='first_look'
    ;cd, dirout
    firstLookDir=outputDir+fLookDir
    fInfo=file_info(fLookDir)
    if ~(fInfo.exists) then file_mkdir, firstLookDir
    sampleImg=rebin(output.fpar, dims[0]/10,dims[1]/10)
    minvalue=min(output.fpar, max=maxvalue)
    sampleImg=bytscl(sampleImg)
    samplefilename='fl_'+new_file+'.gif'
    fullSampleFName=firstLookDir+path_sep()+samplefilename
    LOADCT, 14
    print, 'sampleImage-->', fullSampleFName
    write_gif, fullSampleFName, sampleImg
  endif

  ;  dataSets=[ptr_new(output.fpar, /NO_COPY), ptr_new(output.sigma, /NO_COPY), $
  ;    ptr_new(output.red, /NO_COPY), ptr_new(output.sigma_red, /NO_COPY), $
  ;    ptr_new(output.nir, /NO_COPY), ptr_new(output.sigma_nir, /NO_COPY), $
  ;    ptr_new(output.flag, /NO_COPY), $
  ;    ptr_new(reform(angles[*,*,0]), /NO_COPY), ptr_new(reform(angles[*,*,1]), /NO_COPY), ptr_new(reform(angles[*,*,2]), /NO_COPY), $
  ;    ptr_new(reform(reflectance(*,*,0)), /NO_COPY), ptr_new(reform(reflectance(*,*,1)), /NO_COPY), $
  ;    ptr_new(MASK_avhrr, /NO_COPY)]
  maskMin=min(MASK_avhrr, max=maskMax)
  dataSets=[ptr_new(output.fpar, /NO_COPY), ptr_new(output.sigma, /NO_COPY), $
    ptr_new(output.red, /NO_COPY), ptr_new(output.sigma_red, /NO_COPY), $
    ptr_new(output.nir, /NO_COPY), ptr_new(output.sigma_nir, /NO_COPY), $
    ptr_new(output.flag, /NO_COPY), $
    ptr_new(reform(angles[*,*,0]), /NO_COPY), ptr_new(reform(angles[*,*,1]), /NO_COPY), ptr_new(reform(angles[*,*,2]), /NO_COPY), $
    ptr_new(reform(reflectance(*,*,0)), /NO_COPY), ptr_new(reform(reflectance(*,*,1)), /NO_COPY), $
    ptr_new(MASK_avhrr, /NO_COPY)]

  bandSlopes=[1, 1, $
    10e-05, 10e-05, $
    10e-05, 10e-05, $
    1, $
    10e-03, 10e-03, 10e-03,$
    10e-05, 10e-05,$
    1]

  bandDataType=[1,1,$
    2,2,$
    2,2,$
    1,$
    2,2,2, $
    2,2,$
    1]

  bandIntercepts=lonarr(n_elements(bandNames))

  minMaxs=fltarr(n_elements(bandDataType), 2)
  nanList=fltarr(n_elements(bandDataType))

  minMaxs[*,*]=-1
  minMaxs[0,*]=DATA_RANGE;minMax[0,*]
  nanList[0]=BYTE_NAN

  minMaxs[1,*]=DATA_RANGE;minMax[0,*]
  nanList[1]=BYTE_NAN

  minMaxs[2,*]=DATA_RANGE;minMax[0,*]
  nanList[2]=INT_NAN

  minMaxs[3,*]=DATA_RANGE;minMax[0,*]
  nanList[3]=INT_NAN

  minMaxs[4,*]=DATA_RANGE;minMax[0,*]
  nanList[4]=INT_NAN

  minMaxs[5,*]=DATA_RANGE;minMax[0,*]
  nanList[5]=INT_NAN

  tempMin=min(output.flag, max=tempMax)
  minMaxs[6,*]=[tempMin, tempMax]
  nanList[6]=INT_NAN

  tempMin=min(angles(*,*,0), max=tempMax)
  minMaxs[7,*]=[0.,90.]
  nanList[7]=INT_NAN

  tempMin=min(angles(*,*,1), max=tempMax)
  minMaxs[8,*]=[0.,90.]
  nanList[8]=INT_NAN

  tempMin=min(angles(*,*,2), max=tempMax)
  minMaxs[9,*]=[-180,180]
  nanList[9]=INT_NAN

  tempMin=min(reflectance(*,*,0), max=tempMax)
  minMaxs[10,*]=[tempMin>0.,tempMax]
  nanList[10]=INT_NAN

  tempMin=min(reflectance(*,*,1), max=tempMax)
  minMaxs[11,*]=[tempMin>0.,tempMax]
  nanList[11]=INT_NAN


  minMaxs[12,*]=[maskMin, maskMax]
  nanList[12]=INT_NAN

  boundary=[-180.0, 180.0, -90, 90.]
  filePath=outputDir
  fName=new_file

  write_hdf, hdffilename, $
    bandNames, bandMeasaureUnits, $
    dataSets, bandDataType, bandIntercepts, bandSlopes, tempDir, boundary, $
    trueMinMaxs=minMaxs, nanList=nanList

  write_georef_ncdf, ncfilename, $
    bandNames, bandMeasaureUnits, $
    dataSets, bandDataType, bandIntercepts, bandSlopes, tempDir, boundary, $
    /NOREVERSE, trueMinMaxs=minMaxs, nanList=nanList

  ;
  ;PPMSA_ALBEDOCOLOR
  ;window, 5, xsize=720*2, ysize=360*2, title='Rectified nir '+SENSOR
  ;tv, reverse(congrid(bytscl(output.nir,min=0.,max=0.8), 720*2,360*2),2)

  ;window, 6, xsize=720*2, ysize=360*2, title='Rectified Red '+SENSOR
  ;tv, reverse(congrid(bytscl(output.red, min=0.,max=0.8), 720*2,360*2),2)

  ;faparcolor
  ;window, 7, xsize=720*2, ysize=360*2, title='FAPAR '+SENSOR
  ;tv, reverse(congrid(output.fpar*250.0, 720*2,360*2),2)

  ;stop

  ;

  ;

  ;stop
  ;
end

